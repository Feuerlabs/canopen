@author  Tony Rogvall <tony@rogvall.se>
@version 1.0
@title Erlang CANopen stack
@doc CANopen is an industry standard for managing small embedded nodes
in a CAN network.


See  <a href="http://www.canopensolutions.com/index.html">Canopen</a> for a detailed description of CANopen.

== Architecture ==

The heart of our CANopen implementation is a CoNode. It listens to the CAN bus and acts when a relevent CAN frame is received.<br/>
It has an object dictionary where objects can be stored, deleted and updated.<br/>
The initial dictionary is loaded from a file given as an argument at start up.<br/>
If TPDOs are defined in the dictionary separate TPDO processes are started to handle these.<br/>
It starts SDO session processes when receiving SDO frames.

=== Process structure ===
<img src="../doc/canopen_process_structure.jpg"> </img>

The CoNode is prepared to handle:
<ul>
<li> SDOs - A sdo session process is started to handle the request.</li>
<li> RPDOs - The RPDO is unpacked and the affected objects updated.</li>
<li> DAM-MPDOs - Notifying subscribing applications. </li>
<li> NMT requests - Executes state changs etc.</li>
<li> SYNC pulses - Forwards them to connected TPDO processes.</li>
<li> EMERGENCY requests - Not supported yet.</li>
<li> TIME STAMPS - Not supported yet.</li>
<li> NODE GUARD ?? </li>
<li> LSS requests - Not supported yet.</li>
</ul>

=== Manager ===
If you need a CANopen manager you can use the co_mgr interface, see {@link co_mgr}. It will start a CoNode with NodeId 0.

=== Applications ===
Applications can attach to the CoNode and and reserve or subscribe to indexes in the object dictionary. <br/>
<b>Reserve</b> means that any upload or download requests and notifications connected to that index will be relayed to the application. The CoNode itself does not keep track of these objects. <br/>
<b>Subscribe</b> means that notifications will be relayed to the application. The application will also be notified if the index is handled by the CoNode (included in the co_nodes dictionary) and it's value has been changed.<br/>
When reserving/subscribing to an index a Module parameter is included. <br/><br/>
There is also a possibilty for applications to receive an 'extended' notification comprising of the whole CAN frame. This is acheived via the extended_notification_subscription where a {Module, Function} argument is given. Note that it is then necessary for the application to interpret the CANOpen part, no decoding etc will be done by the CoNode. 


==== SDO interface ====
When an SDO upload/download request is received the function <code>Module:index_specification()</code> is called. The call should return a record of type <code>indec_spec</code> that holds information needed for the data transfer between the co_node and the application. Among these is whether the object value should be transfered atomically, that is once completely, or streamed, that is partioned. You can also here supply a Module parameter meaning that function calls to that module should be used instead of generic gen_server:call.<br/>
Note that when using <b>atomic</b> the value is decoded, whereas when using <b>streamed</b> the value is still a binary since it normally isn't possible to decode it until the complete value is available. <br/> 

This gives the below transfer possibilities:
<ul>
<li><b>atomic</b> - the clauses <code>handle_call({get, ..})</code> (for upload) and <code>handle_call({set, ..})</code> (for download) must exist.</li>
<li><b>streamed</b> - the clauses <code>handle_call({read_begin, ..})</code> and <code>handle_call({read, ..})</code> (for upload) and <code>handle_call({write_begin, ..})</code> and <code>handle_call({write, ..})</code> (for download) must exist. A clause <code>handle_call({abort, ..})</code> is also needed in case the transfer must be aborted.</li>
<li><b>{atomic, Module}</b> - the functions <code>Module:get()</code> (for upload) and <code>Module:set()</code> (for download) will be called.</li>
<li><b>{streamed, Module}</b> - the functions <code>Module:read_begin()</code> and <code>Module:read()</code> (for upload) and <code>Module:write_begin()</code> and <code>Module:write()</code> (for download) will be called. A function <code>abort())</code> is also needed in case the transfer must be aborted.</li>
</ul>

There are two behaviours defined for the above:
<ul>
<li>co_app - For applications using the {Module, atomic} transfer mode. See {@link co_app}.</li>
<li>co_stream_app - For applications using the {Module, streamed} transfer mode. See {@link co_stream_app}.</li>
</ul>

==== TPDO interface ====
When an application has reserved an index that is included in a TPDO the TPDO process infor
The application must thus have a function <code>Module:tpdo_callback()</code> that is called by the TPDO process when it builds its TPDO map. In this way the application is given a Module:Function that it should call as soon as the value of the given index is changed. It is god practise for the application to call this immediately to replace the default value stored in the co_node with the current value. <br/>

There is one behaviour defined for the above:
<ul>
<li>co_tpdo_app - For applications reserving an index included in a TPDO. See {@link co_tpdo_app}.</li>
</ul>

=== Modules ===
====Header files ====
<ul>
<li> canopen - Definitions, for example of records used as loop_data in various processes. <a href="../include/canopen.hrl">`canopen.hrl'</a> </li>
<li> sdo - Definitions of SDO PDUs.  <a href="../include/sdo.hrl">`sdo.hrl'</a> </li>
<li> co_app - Definitions needed for applications wanting to attach to the CANopen node co_node. <a href="../include/co_app.hrl">`co_app.hrl'</a> </li>
<li> co_debug - Debug macro. <a href="../include/co_debug.hrl">`co_debug.hrl'</a></li>
</ul>
=== Source files ===
<ul>
<li> canopen - CANopen application. Starts the CANopen supervisor.</li>
<li> canopen_sup - CANopen supervisor. Starts the CANopen node (co_node).</li>
<li> co_api - Interface to the CANopen node (co_node).</li>
<li> co_node - CANopen node. Processes CANopen frames.</li>
<li> co_mgr - CANopen manager interface. </li>
<li> co_os_app - Application that implements support for OS_COMMAD, index 16#1023 </li>
<li> co_file - Loads symbolic entries from a file. </li>
<li> co_dict - Accesses the CANopen internal object dictionary. </li>
<li> co_sdo_srv_fsm - State machine handling an SDO RX interchange. </li>
<li> co_sdo_cli_fsm - State machine handling an SDO TX interchange. </li>
<li> co_session - Common functions for SDO interchange. </li>
<li> co_data_buf - Intermediate data storage during an SDO interchange.</li>
<li> co_sdo - Encode/decode of SDO frames to erlang records. </li>
<li> co_tpdo - Process managing one TPDO. </li>
<li> co_set_fsm - State machine for transmitting data from an RPDO to an application.</li>
<li> co_app - Behaviour for an application using the {atomic, Module} transfer mode.. </li>
<li> co_stream_app - Behaviour for an application using the {streamed, Module} transfer mode.. </li>
<li> co_codec - CANbit encoding and decoding. </li> 
<li> co_lib - Support functions. </li> 
<li> co_crc - Checksum calculation. </li>
<li> co_iset - Integer set. </li>
<li> co_probe - For tracing. CANopen probe. </li>
<li> co_format - For tracing. Converts CANopen records to readable form. </li>
</ul>
