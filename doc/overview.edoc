@author  Tony Rogvall <tony@rogvall.se>
@version 1.0
@title Erlang CANopen stack
@doc CANopen is an industry standard for managing small embedded nodes
in a CAN network.

See .. for a detailed description of CANopen.

The central concept i CANopen is the object dictionary ...

Indexes are of several types:
<ul>
<li>16#0000 - 16#1FFF are defined by the standard and can be subscribed to by many applications but reserved by none.</li>
<li>16#2000 - 16#5FFF are manufacture specific and can be subscribed to by many applications but reserved by at most one.</li>
<li>16#6000 - 16#9FFF are device specific and can be subscribed to by many applications and reserved by at most one application.</li>
</ul>

Applications can attach to the co_node and and reserve or subscribe to indexes in the object dictionary. <br/>
<b>Reserve</b> means that any upload or download requests and notifications connected to that index will be relayed to the application. <br/>
<b>Subscribe</b> means that notifications will be relayed to the application. The application will also be notified if the index is handled by the co_node (included in the co_nodes dictionary) and it's value has been changed.<br/>

When reserving an index a Module parameter is included. When an upload/download request is received the function <code>Module:get_entry()</code> is called. The call should return a record of type app_entry that holds information needed for the data transfer between the co_node and the application. Among these is whether the object value should be transfered atomically, that is once completely regardless of how many CANopen frames it requires, or streamed, that is partioned as in the CANopen frames. You can also supply a Module parameter meaning that function calls to that module should be used instead of generic gen_server:call or gen_server:cast.<br/>
Note that when using <br>atomic</br> the value is decoded, whereas when using <br>streamed</br> the value is still a binary since it normally isn't possible to decode it until the complete value is available. <br/> 
The interface for download is asynchronic, whereas the interface for upload is synchronic to avoid flooding. <br/>

This gives the below transfer possibilities:
<ul>
<li><b>atomic</b> - the clauses <code>handle_call({get, ..})</code> (for upload) and <code>handle_call({set, ..})</code> (for download) must exist.</li>
<li><b>streamed</b> - the clauses <code>handle_call({read_begin, ..})</code> and <code>handle_call({read, ..})</code> (for upload) and <code>handle_call({write_begin, ..})</code> and <code>handle_call({write, ..})</code> (for download) must exist. </li>
<li><b>{atomic, Module}</b> - the functions <code>Module:get()</code> (for upload) and <code>Module:set()</code> (for download) will be called.</li>
<li><b>{streamed, Module}</b> - the functions <code>Module:read_begin()</code> and <code>Module:read()</code> (for upload) and <code>Module:write_begin()</code> and <code>Module:write()</code> (for download) will be called.</li>
</ul>

